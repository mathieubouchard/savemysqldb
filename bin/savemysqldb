#!/usr/bin/python
# -*- coding: utf-8

# Create a backup of all mysql databases
# Mathieu Bouchard

from ConfigParser import ConfigParser
from datetime import datetime
from subprocess import Popen, PIPE
from datetime import datetime
import socket, logging, sys, os

CONFIGFILE = "/etc/savemysqldb.conf"
DEFAULT_CONFIG = {"DB_DIR": "/var/lib/mysql",
                  "TMP_DIR": "/tmp/backup",
                  "BACKUP_DIR": "/home/backup/mysql",
                  "MYSQLHOTCOPY_BIN": "/usr/bin/mysqlhotcopy",
                  "TAR_BIN": "/bin/tar",
                  "DB_USER": "root",
                  "DB_PASSWD": "",
                  "EXCEPTIONS": [],
                  "LOG_FILENAME": "/var/log/savemysqldb.log"}

class Config(object):
    def __init__(self):
        """Open a configuration file and load it's contents

        @param config_file: The configuration files
        @type config_file: str or [ str ]
        """
        self.__dict__ = DEFAULT_CONFIG

    def read(self, config_file):
        """Create a dict from the complete file strucure

        @return: The dict read from the config file
        @rtype: { str : { str : str } }
        """
        config = ConfigParser()
        conf_files = config.read(config_file)

        for section in config.sections():
            for option in config.options(section):
                option = option.upper()
                if option == "EXCEPTIONS":
                    self.__dict__[option] = config.get(section, option).split()
                else:
                    self.__dict__[option] = config.get(section, option)
        return conf_files

def findDatabases(config):
    """Find the list of databases that needs to be dumped

    @param config: Program configuration
    @type config: Config

    @return: The list of databases
    @rtype: [ str ]
    """
    return [x for x in os.listdir(config.DB_DIR) \
            if os.path.isdir(os.path.join(config.DB_DIR, x)) \
               and x not in config.EXCEPTIONS]

def findTables(database, config):
    """Find the list of tables in a database (mysql database files suffix
    if .MYD)

    @param database: The name of the database
    @type database: str
    @param config: Program configuration
    @type config: Config

    @return: The list of tables
    @rtype: [ str ]
    """
    return [os.path.splitext(x)[0]
            for x in os.listdir(os.path.join(config.DB_DIR, database)) \
            if os.path.isfile(os.path.join(config.DB_DIR, database, x)) \
               and os.path.splitext(x)[1].upper() == ".MYD"]

def dumpDatabases(databases, config):
    """Create a hot copy of the selected databases using mysqlhotcopy

    @param databases: The list of databases to dump
    @type databases: [ str ]
    @param config: Program configuration
    @type directory: Config
    """
    if os.path.exists(config.TMP_DIR):
        os.system("/bin/rm -rf %s" % config.TMP_DIR)
    os.makedirs(config.TMP_DIR)

    for database in databases:
        tables = findTables(database, config)
        first_table = True
        for table in tables:
            # Create the command line
            command = [config.MYSQLHOTCOPY_BIN, "-u", config.DB_USER]
            if config.DB_PASSWD != "":
                command.extend(["-p", config.DB_PASSWD])
            if first_table:
                command.append("--allowold")
                first_table = False
            else:
                command.append("--addtodest")
            command.extend(["%s./%s/" % (database, table), config.TMP_DIR])

            process = Popen(command, stdout = PIPE, stderr = PIPE)
            process.wait()
            if process.returncode != 0:
                raise OSError("mysqlhotcopy: %s" % process.communicate()[1])

def compress(databases, config):
    if not os.path.exists(config.TAR_BIN):
        raise OSError("%s is not a tar executable" % config.TAR_BIN)
    elif not os.path.exists(config.BACKUP_DIR):
        os.makedirs(config.BACKUP_DIR)
    elif not os.path.isdir(config.BACKUP_DIR):                
        raise OSError("%s is not a directory" % config.BACKUP_DIR)

    compressed_filename = os.path.join(config.BACKUP_DIR, "mysql-db-backup_%s.tar.bz2" % \
                                       (datetime.now().strftime("%Y-%m-%d_%H%M%S")))
    logging.info("Compressing data to %s" % (compressed_filename))

    command = [config.TAR_BIN, "jcf", compressed_filename]
    command.extend(databases)
    os.chdir(config.TMP_DIR)

    process = Popen(command, stdout = PIPE, stderr = PIPE)
    process.wait()
    if process.returncode != 0:
        raise OSError("mysqlhotcopy (compress): %s" % process.communicate()[1])

if __name__ == "__main__":
    # Get program configuration
    config = Config()
    used_configfile = config.read(CONFIGFILE)

    try:
        logging.basicConfig(filename = config.LOG_FILENAME, level = logging.INFO,
                            format = "%(asctime)s:%(levelname)s:%(name)s:%(message)s",
                            datefmt = "%Y-%m-%d %H:%M:%S")
    except IOError:
        print "Unable to open log file (%s) in write mode" % config.LOG_FILENAME
    logging.info("Starting backup")
    if len(used_configfile) > 0:
        logging.info("Using config file: %s" % used_configfile)
    else:
        logging.info("Using default config")
    logging.info("  DB_DIR: %s" % config.DB_DIR)
    logging.info("  BACKUP_DIR: %s" % config.BACKUP_DIR)

    try:
        # Create the list of databases
        databases = findDatabases(config)
        logging.info("We will save the following databases: %s" % " ".join(databases))
        # Dump the databases
        dumpDatabases(databases, config)
        logging.info("Backup complete")
        # Compress and archive the data
        compress(databases, config)
        logging.info("Compression complete")
        # Cleanup
        os.system("/bin/rm -rf %s" % config.TMP_DIR)
    except OSError, e:
        message = "%s: %s: %s" % (socket.gethostname(), __file__, str(e))
        logging.error(message)
        print message
        sys.exit(1)
