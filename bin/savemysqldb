#!/usr/bin/python
# -*- coding: utf-8

# Create a backup of all mysql databases
# Mathieu Bouchard

from ConfigParser import ConfigParser
from datetime import datetime
import subprocess
import tempfile
import logging
import socket
import shutil
import os

CONFIGFILE = "/etc/savemysqldb.conf"
DEFAULT_CONFIG = {"DB_DIR": "/var/lib/mysql",
                  "BACKUP_DIR": "/home/backup/mysql",
                  "MYSQLDUMP_BIN": "/usr/bin/mysqldump",
                  "TAR_BIN": "/bin/tar",
                  "DB_USER": "root",
                  "DB_PASSWD": "",
                  "DB_HOST": "",
                  "DB_PORT": "",
                  "EXCEPTIONS": [],
                  "LOG_FILENAME": "/var/log/savemysqldb.log"}

class Config(object):
    def __init__(self):
        """Open a configuration file and load it's contents

        @param config_file: The configuration files
        @type config_file: str or [ str ]
        """
        self.__dict__ = DEFAULT_CONFIG

    def read(self, config_file):
        """Create a dict from the complete file strucure

        @return: The dict read from the config file
        @rtype: { str : { str : str } }
        """
        config = ConfigParser()
        conf_files = config.read(config_file)

        for section in config.sections():
            for option in config.options(section):
                option = option.upper()
                if option == "EXCEPTIONS":
                    self.__dict__[option] = config.get(section, option).split()
                else:
                    self.__dict__[option] = config.get(section, option)
        return conf_files

def findDatabases(config):
    """Find the list of databases that needs to be dumped

    @param config: Program configuration
    @type config: Config

    @return: The list of databases
    @rtype: [ str ]
    """
    return [x for x in os.listdir(config.DB_DIR) \
            if os.path.isdir(os.path.join(config.DB_DIR, x)) \
               and x not in config.EXCEPTIONS]

def findTables(database, config):
    """Find the list of tables in a database (mysql database files suffix
    if .MYD)

    @param database: The name of the database
    @type database: str
    @param config: Program configuration
    @type config: Config

    @return: The list of tables
    @rtype: [ str ]
    """
    return [os.path.splitext(x)[0]
            for x in os.listdir(os.path.join(config.DB_DIR, database)) \
            if os.path.isfile(os.path.join(config.DB_DIR, database, x)) \
               and os.path.splitext(x)[1].upper() == ".MYD"]

def dumpDatabases(databases, config, tmpdir):
    """Create a dump of the selected databases using mysqldump

    @param databases: The list of databases to dump
    @type databases: [ str ]
    @param config: Program configuration
    @type directory: Config
    """
    for database in databases:
        command = [config.MYSQLDUMP_BIN, "-u", config.DB_USER]
        if config.DB_PASSWD != "":
            command.extend(["-p%s" % config.DB_PASSWD])
        if config.DB_HOST != "":
            command.extend(["-h", config.DB_HOST])
        if config.DB_PORT != "":
            command.extend(["-P", config.DB_PORT])
        command.extend([database])
        output_file = file(os.path.join(tmpdir, "%s.sql" % database), "w")

        process = subprocess.Popen(command, stdout = output_file, stderr = subprocess.PIPE)
        process.wait()
        output_file.close()
        if process.returncode != 0:
            raise OSError("mysqldump: %s" % process.communicate()[1])

def compress(databases, config, tmpdir):
    if not os.path.exists(config.TAR_BIN):
        raise OSError("%s is not a tar executable" % config.TAR_BIN)
    elif not os.path.exists(config.BACKUP_DIR):
        os.makedirs(config.BACKUP_DIR)
    elif not os.path.isdir(config.BACKUP_DIR):                
        raise OSError("%s is not a directory" % config.BACKUP_DIR)

    compressed_filename = os.path.join(config.BACKUP_DIR, "mysql-db-backup_%s.tar.bz2" % \
                                       (datetime.now().strftime("%Y-%m-%d_%H%M%S")))
    logging.info("Compressing data to %s" % (compressed_filename))

    command = [config.TAR_BIN, "jcf", compressed_filename]
    command.extend(["%s.sql" % x for x in databases])
    os.chdir(tmpdir)

    process = subprocess.Popen(command, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    process.wait()
    if process.returncode != 0:
        raise OSError("mysqldump (compress): %s" % process.communicate()[1])

    return compressed_filename

if __name__ == "__main__":
    # Get program configuration
    config = Config()
    used_configfile = config.read(CONFIGFILE)

    try:
        logging.basicConfig(filename = config.LOG_FILENAME, level = logging.INFO,
                            format = "%(asctime)s:%(levelname)s:%(name)s:%(message)s",
                            datefmt = "%Y-%m-%d %H:%M:%S")
    except IOError:
        sys.stderr.write("Unable to open log file (%s) in write mode\n" % config.LOG_FILENAME)
    logging.info("Starting backup")
    if len(used_configfile) > 0:
        logging.info("Using config file: %s" % used_configfile)
    else:
        logging.info("Using default config")
    logging.info("  DB_DIR: %s" % config.DB_DIR)
    logging.info("  BACKUP_DIR: %s" % config.BACKUP_DIR)

    try:
        # Create the list of databases
        databases = findDatabases(config)
        logging.info("We will save the following databases: %s" % " ".join(databases))
        # Dump the databases
        tmpdir = tempfile.mkdtemp()
        dumpDatabases(databases, config, tmpdir)
        logging.info("Backup complete")
        # Compress and archive the data
        compressed_filename = compress(databases, config, tmpdir)
        logging.info("Compression complete")
        # Cleanup
        shutil.rmtree(tmpdir)
        # Create the latest link
        latest_link = os.path.join(config.BACKUP_DIR, "mysql-db-backup-latest.tar.bz2")
        if os.path.exists(latest_link):
            os.unlink(latest_link)
        os.symlink(os.path.basename(compressed_filename), latest_link)
    except OSError, e:
        message = u"%s: %s: %s" % (socket.gethostname(), __file__, unicode(e))
        logging.error(message)
        sys.stderr.write(u"%s\n" % message)
        sys.exit(1)

